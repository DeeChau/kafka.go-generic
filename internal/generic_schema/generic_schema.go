// Modified from code generated by github.com/wishabi/kafka.go.
package generic_schema

import (
	"io"
	"log"

	"github.com/actgardner/gogen-avro/v7/compiler"
	"github.com/actgardner/gogen-avro/v7/vm"
	"github.com/actgardner/gogen-avro/v7/vm/types"

	schema "github.com/DeeChau/kafka.go-generic/internal/schema"
)

// Extractable into another class via. generation! ->
// TODO: Have a config file as code -> Look into how this is done in other Go Apps.
// Generate schema classes (ohoho) based on the config -> Consumer/Producer.
type AvroSchemaConstraint interface {
	schema.Fsa | schema.FsaKey | schema.State | schema.StateKey
}

// This is needed
type AvroSchemaStruct[S any] interface {
	Serialize(w io.Writer) error
	Schema() string
	SchemaName() string
	Get(i int) types.Field
	SetBoolean(v bool)
	SetInt(v int32)
	SetLong(v int64)
	SetFloat(v float32)
	SetDouble(v float64)
	SetBytes(v []byte)
	SetString(v string)
	SetUnionElem(v int64)
	AppendMap(key string) types.Field
	AppendArray() types.Field
	Finalize()
	AvroCRC64Fingerprint() []byte
	SetDefault(i int)
	NullField(i int)
	*S
}

// Schema SerDe
// TODO: -> Add unit tests!
func DeserializeFromSchema[S AvroSchemaConstraint, PT AvroSchemaStruct[S]](r io.Reader, avroSchema string) (*PT, error) {
	t := NewSchemaStruct[S, PT]()
	// t := PT(new(S))
	deser, err := compiler.CompileSchemaBytes([]byte(avroSchema), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}
	err = vm.Eval(r, deser, t)
	if err != nil {
		return nil, err
	}
	log.Printf("Consumer deserialized %T message: %s", t, t)
	return &t, err
}

func NewSchemaStruct[S AvroSchemaConstraint, PT AvroSchemaStruct[S]]() PT {
	return PT(new(S))
}
