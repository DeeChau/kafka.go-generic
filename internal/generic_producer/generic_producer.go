// Modified from code generated by github.com/wishabi/kafka.go.
package genericproducers

import (
	"context"
	"fmt"

	"github.com/segmentio/kafka-go"
	"github.com/wishabi/kafka.go/avro"

	genericschema "github.com/DeeChau/kafka.go-generic/internal/generic_schema"
)

// AvroProducer kafka producer for the Schema Type Fsa
type AvroProducer[K, V any, PTK genericschema.AvroSchemaStruct[K], PTV genericschema.AvroSchemaStruct[V]] struct {
	writer   *kafka.Writer
	registry *avro.Registry
	topic    string
}

// // Produce publish a message using key and value
func (p *AvroProducer[K, V, PTK, PTV]) Produce(ctx context.Context, key *K, value *V) error {
	keySchemaID, err := p.registry.SchemaID(p.topic+"-key", PTK(key).Schema())
	if err != nil {
		return err
	}

	keyBuffer := avro.Build(keySchemaID)
	err = PTK(key).Serialize(keyBuffer)
	if err != nil {
		return fmt.Errorf("failed to write FsaKey to buffer: %w", err)
	}

	valueSchemaID, err := p.registry.SchemaID(p.topic+"-value", PTV(value).Schema())
	if err != nil {
		return err
	}

	valueBuffer := avro.Build(valueSchemaID)
	err = PTV(value).Serialize(valueBuffer)
	if err != nil {
		return fmt.Errorf("failed to write Fsa to buffer: %w", err)
	}

	err = p.writer.WriteMessages(ctx, kafka.Message{
		Key:   keyBuffer.Bytes(),
		Value: valueBuffer.Bytes(),
	})

	if err != nil {
		return fmt.Errorf("failed to publish Fsa to kafka: %w", err)
	}

	return nil
}

// NewAvroProducer creates a generic producer for sending a message.
func NewAvroProducer[K, V any, PTK genericschema.AvroSchemaStruct[K], PTV genericschema.AvroSchemaStruct[V]](
	config kafka.WriterConfig, registry *avro.Registry) *AvroProducer[K, V, PTK, PTV] {
	return &AvroProducer[K, V, PTK, PTV]{
		writer:   kafka.NewWriter(config),
		registry: registry,
		topic:    config.Topic,
	}
}
